AutoTidy MVP - Technical Design Document (TDD)
Version: 1.0 (Python/PyQt Stack)
Date: April 15, 2025

1. System Overview

High-level Description: AutoTidy is a desktop utility application built in Python using the PyQt/PySide framework. It runs in the background, monitoring user-specified folders. Based on configured rules (file age, filename pattern), it moves eligible files into dated subdirectories within the monitored folder. The application provides a minimal UI via a system tray icon and a small configuration window.

Platform: Cross-platform Desktop Application targeting Windows and Linux, built with Python and PyQt/PySide.

2. Tech Stack

Language: Python (Version 3.8+ recommended).

UI Framework: PyQt (v5 or v6) or PySide (v2 or v6). Provides cross-platform GUI widgets, system tray integration, and event loop.

Core Logic Libraries:

File System: Python's built-in os, shutil, pathlib, datetime.

Background Task/Scheduling: Python's threading module for running monitoring in a non-blocking way. A simple time.sleep() or the schedule library within the thread for periodic checks. (Decision for MVP: Start with threading + periodic time.sleep() for simplicity).

Pattern Matching: fnmatch module (simpler) or re module (more powerful). (Decision for MVP: Start with fnmatch).

State Management: Configuration stored locally (e.g., JSON file). Application state managed within Python classes.

Build & Packaging: PyInstaller or potentially cx_Freeze / Briefcase to create executable bundles for Windows and Linux.

3. Architecture & Data Flow

Key Components:

Main Application (QApplication): Initializes the app, manages the Qt event loop, sets up tray icon and main window.

System Tray Icon (QSystemTrayIcon): Provides tray presence, context menu (Add Folder, Start/Stop, Quit), tooltip. Handles activation (show window).

Configuration Window (QWidget or QMainWindow): UI elements (buttons, list, inputs, log view). Emits signals on user action. Contains slots to update UI from worker signals.

Configuration Manager (Python Class): Loads/saves settings (list of dictionaries: {'path': '/path/to/folder', 'age_days': 7, 'pattern': '*.tmp'}) from/to a local JSON file. Provides methods to add/remove/update monitored folders.

Monitoring Worker (Python Class running in threading.Thread):

Runs the core monitoring loop in a separate thread.

Holds a list of folders/rules to monitor (obtained from Config Manager).

Contains the main loop (e.g., while not self.stopped:).

Inside loop: iterates folders, calls Rule Engine, calls File Mover.

Uses a thread-safe mechanism (e.g., queue.Queue or PyQt signals if using QObject worker + moveToThread) to send status/log/error messages back to the main UI thread.

Includes a start/stop mechanism (e.g., checking self.stopped flag).

Sleeps periodically (time.sleep(3600) for hourly checks, maybe shorter for testing).

Rule Engine (Python Functions/Class): Takes file path, age threshold (days), pattern string. Returns True if file matches rules (checks modification time using os.path.getmtime and filename using fnmatch.fnmatch).

File Mover (Python Functions/Class): Takes source file path, base monitored path. Calculates target _Cleanup/YYYY-MM-DD path. Creates target directory (os.makedirs(exist_ok=True)). Moves file (shutil.move). Handles potential FileNotFoundError, PermissionError.

Data Flow:

App starts -> QApplication runs -> Config Manager loads JSON -> Main Window created (hidden) -> Tray Icon shown.

Monitoring Worker thread started (if enabled/auto-start).

User clicks Tray Icon -> Main Window shown.

User adds folder via UI -> Signal -> Slot calls Config Manager -> Config saved -> Worker potentially notified to reload config.

Worker thread loop runs -> Scans folder -> Rule Engine checks file -> Match found -> File Mover called.

File Mover moves file -> Worker puts status message ("Moved X to Y") onto queue/emits signal.

Main thread reads queue/receives signal -> Updates UI log view.

Error in File Mover -> Worker puts error message onto queue/emits signal -> Main thread reads/receives -> Shows QMessageBox.

4. Feature Implementation Notes

Folder Selection: Use QFileDialog.getExistingDirectory.

Rule Inputs: QLineEdit for pattern, QSpinBox for age (days).

File Moving: os.path.getmtime, datetime.datetime.fromtimestamp, datetime.timedelta, fnmatch.fnmatch, os.makedirs(exist_ok=True), shutil.move.

Background Operation: Use threading.Thread. Communication back to UI thread via queue.Queue (put from worker, get in main thread using a QTimer to check queue periodically) or use QObject.moveToThread for signal/slot mechanism (more complex setup but cleaner integration). MVP Decision: Start with threading.Thread + queue.Queue + QTimer check.

Status View: Read-only QTextEdit updated from main thread based on messages from worker queue. QLabel for simple Running/Stopped status.

5. Error Handling

Use try...except blocks in worker thread for file operations (FileNotFoundError, PermissionError, OSError).

Send error messages back to main thread via the queue/signal mechanism.

Display critical errors using QMessageBox.warning or critical in the main thread.

Log non-critical errors/warnings to the UI log view.

Handle inaccessible monitored folders by logging the error and skipping that folder for the current check cycle.

6. Data Handling & Security

Configuration Storage: JSON file (e.g., config.json) in user config directory (%APPDATA%\AutoTidy or ~/.config/AutoTidy). Use os.path.expanduser('~'), platform.system(), or appdirs library to find appropriate location. Load/save using Python's json module.

Log Storage: Session-based in UI QTextEdit. No persistent log files for MVP.

Privacy: Local operation only. No network access needed. File system access limited to configured paths and standard operations (stat, move, makedirs).

7. Development Timeline

Estimated maximum of 1 month. Focus on core functionality. Packaging with PyInstaller might require dedicated time for testing and resolving issues on both Windows and Linux.